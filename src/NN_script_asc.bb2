#ML_op_noop             = 0     ; No operation
#ML_op_clrf             = 1     ; #ML_op_clrf       id      -- Clear flag by id
#ML_op_setf             = 2     ; #ML_op_setf       id      -- Set flag by id
#ML_op_togf             = 3     ; #ML_op_togf       id      -- Toggle flag by id
#ML_op_getf             = 4     ; #ML_op_getf       id      -- Place flag in flag register
#ML_op_and              = 5     ; #ML_op_and        id      -- AND the flag register with flag, store in register. 
#ML_op_or               = 6     ; #ML_op_or         id      -- OR the flag register with flag, store in register.
#ML_op_not              = 7     ; #ML_op_not                -- NOT the flag register, store in register
#ML_op_jump             = 8     ; #ML_op_jump       num     -- Skip the next 'num' words
#ML_op_jpns             = 9     ; #ML_op_jpns       num     -- Skip ahead a 'num' words if the flag register is not set
#ML_op_end              = 10    ; #ML_op_end                -- Ends script execution
#ML_op_setbg            = 11    ; #ML_op_setbg      id      -- Sets bitmap id as the background of the scene
#ML_op_setsh            = 12    ; #ML_op_setsh      id x y  -- Draw shape id at x, y
#ML_op_addinv           = 13    ; #ML_op_addinv     id      -- Adds item id to inventory
#ML_op_reminv           = 14    ; #ML_op_reninv     id      -- Removes item from inventory
#ML_op_hasinv           = 15    ; #ML_op_hasinv     id      -- Check if items is in inventory, updates flag register
#ML_op_text             = 16    ; #ML_op_text       id      -- Displays text
#ML_op_gameover         = 17    ; #ML_op_gameover   id      -- Ends game, displays text

; An item in Neon Noir
;
NEWTYPE .NN_item
    id.w                        ; Shape id for this item in the inventory
    name.w                      ; String id for the item's name
    desc.w                      ; String if for the item's description
End NEWTYPE


Dim NN_flags.b(512)             ; All the flags
Dim ML_data.w(512)              ; All of the scripts

Dim NN_text.s(128)              ; All the strings in Neon Noir
Dim NN_items.NN_item(128)       ; All the items in Neon Noir
Dim List NN_inventory.w(128)    ; The player's inventory

Statement NN_SetBackground{id.w}
    NPrint "*** Set background to ", id
End Statement

Statement NN_SetShape{id.w, x.w, y.w}
    NPrint "*** Set shape ", id, " at ", x, ", ", y
End Statement

Statement NN_AddInventory{id.w}
    SHARED NN_inventory(), NN_items()

    AddLast NN_inventory()
    NN_inventory(NN_items(id))

    NPrint "*** Added ", NN_items(id)\name, " to inventory"
End Statement

Statement NN_RemoveInventory{id.w}
End Statement

Function .b NN_HasInventoryItem{id.w}
    Function Return True
End Function

Statement NN_DisplayText{id.w}
    SHARED NN_text()

    NPrint NN_text(id)
End Statement

Statement NN_GameOver{id.w}
    SHARED NN_text()

    NPrint "GAME OVER: ", NN_text(id)
End Statement

Statement ML_execute_script{script_start.w, script_length.w}
    SHARED ML_data(), NN_flags()    ; get a reference to the script data and game flags

    pc.w = script_start         ; set up the program counter
    eos.w = pc + script_length  ; figure out the last address of the script
    flag_register = False       ; set up the flag register

    Repeat
        Select ML_data(pc)
            Case #ML_op_noop
                pc + 1          ; eat the opcode

            Case #ML_op_clrf; id
                pc + 1          ; eat the opcode
                NN_flags(ML_data(pc)) = False
                pc + 1          ; eat the parameter

            Case #ML_op_setf; id
                pc + 1          ; eat the opcode
                NN_flags(ML_data(pc)) = True
                pc + 1          ; eat the parameter

            Case #ML_op_togf; id
                pc + 1          ; eat the opcode
                NN_flags(ML_data(pc)) = NOT NN_flags(ML_data(pc))
                pc + 1          ; eat the parameter

            Case #ML_op_getf; id
                pc + 1          ; eat the opcode
                flag_register = NN_flags(ML_data(pc))
                pc + 1          ; eat the parameter

            Case #ML_op_and; ic
                pc + 1          ; eat the opcode
                flag_register = flag_register and NN_flags(ML_data(pc))
                pc + 1          ; eat the parameter

            Case #ML_op_or; ic
                pc + 1          ; eat the opcode
                flag_register = flag_register or NN_flags(ML_data(pc))
                pc + 1          ; eat the parameter

            Case #ML_op_not
                pc + 1          ; eat the opcode
                flag_register = not flag_register

            Case #ML_op_jump; amount
                pc + 1          ; eat the opcode
                pc + ML_data(pc)
                pc + 1          ; eat the parameter

            Case #ML_op_jpns; amount
                pc + 1          ; eat the opcode
                if not flag_register then pc = pc + ML_data(pc)
                pc + 1          ; eat the parameter

            Case #ML_op_end
                pc = eos        ; jump to the end of the script

            Case #ML_op_setbg; id
                pc + 1          ; eat the opcode
                NN_SetBackground{ML_data(pc)}
                pc + 1          ; eat the parameter

            Case #ML_op_setsh; id x y
                pc + 1          ; eat the opcode
                NN_SetShape{ML_data(pc), ML_data(pc + 1), ML_data(pc + 2)}
                pc + 3          ; eat the parameters

            Case #ML_op_addinv; id
                pc + 1          ; eat the opcode
                NN_AddInventory{ML_data(pc)}
                pc + 1          ; eat the parameter

            Case #ML_op_reminv; id
                pc + 1          ; eat the opcode
                NN_RemoveInventory{ML_data(pc)}
                pc + 1          ; eat the parameter

            Case #ML_op_hasinv; id
                pc + 1          ; eat the opcode
                flag_register = NN_HasInventoryItem{ML_data(pc)}
                pc + 1          ; eat the parameter

            Case #ML_op_text; id
                pc + 1          ; eat the opcode
                NN_DisplayText{ML_data(pc)}
                pc + 1          ; eat the parameter

            Case #ML_op_gameover
                pc + 1          ; eat the opcode
                NN_DisplayText{ML_data(pc)}
                pc + 1          ; eat the parameter

            Default
                ; Unknown opcode!
                NPrint "*** Error! Unknown opcode!"
                NPrint "PC: ", pc, "    Opcode: ", ML_data(pc)
                pc = eos
        End Select

    Until pc >= eos              ; Continue until we're at the End of Script
End Statement

NN_text(0) = "Oh no! Danger ahead!"
NN_text(1) = "Oops, ya died."
NN_text(2) = "Ya did it, kid."

ML_data(0) = #ML_op_text
ML_data(1) = 0

ML_data(2) = #ML_op_getf    ; Get flag 0, it should be false
ML_data(3) = 0

ML_data(4) = #ML_op_jpns    ; If the flag is false (which is it, skip this next part)
ML_data(5) = 3

ML_data(6) = #ML_op_gameover
ML_data(7) = 1
ML_data(8) = #ML_op_end

ML_data(9) = #ML_op_text
ML_data(10) = 2
ML_data(11) = #ML_op_end

ML_execute_script{0, 12}










XINCLUDE "NS_opcodes.bb2"
XINCLUDE "NN_game.bb2"
XINCLUDE "IV_inventory.bb2"
XINCLUDE "SH_shapes.bb2"
XINCLUDE "SC_scene.bb2"

NEWTYPE.NS_script
    offset.w
    size.w
End NEWTYPE

DEFTYPE .l NS_data_ptr, NS_data_size, NS_specs_ptr
DEFTYPE .w NS_num_scripts

Dim NS_flags.b(256)

#NS_magic = $4E533031 ; 'NS01'

Function.b NS_initialize{bytecode_file$}
    SHARED NS_data_ptr, NS_data_size, NS_specs_ptr, NS_num_scripts

    If Exists(bytecode_file$) = 0
        NPrint "Bytecode file ", bytecode_file, " does not exist."
        Function Return False
    End If

    DEFTYPE .w id, num_scripts
    id = 0
    If ReadFile(id, bytecode_file$)
        FileInput id

        ; The file should have a NS01 in the first 4 bytes, 4E 53 30 31
        DEFTYPE .l magic
        ReadMem id, &magic, 4
        If magic <> #NS_magic
            NPrint bytecode_file, " is not a valid NoirScript bytecode file."
            Function Return False
        End If

        ; Next we see how many scripts are in this file
        DEFTYPE .l spec_size
        ReadMem id, &NS_num_scripts, 2
        spec_size = NS_num_scripts *  SizeOf .NS_script
        NS_specs_ptr = AllocMem(spec_size, $10000)
        ReadMem id, NS_specs_ptr, spec_size

        ; Exclude the 4 byte for the magic number, -2 for the number of scripts
        ; -spec_size for the script specifications
        NS_data_size = Lof(id) - 4 - 2 - spec_size
        NS_data_ptr = AllocMem(NS_data_size, $10000) ; Best available and clear
        ReadMem id, NS_data_ptr, NS_data_size

        CloseFile id
        PopInput
    End If

    Function Return True
End Function

; Executes the bytecode pointed to in the script
; Assumes the existence of this global data:
;   NS_data: Word array containing the opcodes to all the scrips
;   NS_flags: Byte array containing all of the game's flags
; And these global statements/functions
;   NN_game_over: Transition to game over screen
;   NN_display_text: Show text on the screen
;   IV_has_item: Check if an item is in the inventory
;   IV_add_item: Adds an item to the inventory
;   IV_remvoe_item: Removes and item from the inventory
;   SH_draw: Draws a shape
;   SC_set_bg: Sets the background in a scene
;   NN_game_set_scene: Goes to a new scene
;   NN_game_map: Display the map with locations
Statement NS_execute_script{script_id.w}
    SHARED NS_data_ptr, NS_flags()    ; get a reference to the script data and game flags
    SHARED NS_specs_ptr, NS_num_scripts


    ; Get the referenced script
    If script_id > NS_num_scripts
        NPrint "Script index", script_id, " out of bounds";
        Statement Return
    End If

    DEFTYPE .NS_script script
    DEFTYPE .l spec_ptr
    spec_ptr = script_id * SizeOf .NS_script
    CopyMem_ spec_ptr, &script, SizeOf .NS_script

    PC.w = script\offset             ; Set up program counter
    EOS.w = PC + script\size * 2  ; Figure out the end of script is
    FR.b = False                    ; Initialize Flag Register

    DEFTYPE .w v1, v2, v3
    Repeat
        Select Peek.w (NS_data_ptr + PC)
            Case #NS_op_noop
                PC + 2              ; Eat the opcode

            ; Flag register operations
            Case #NS_op_clear
                PC + 2              ; Eat the opcode
                FR = False

            Case #NS_op_set
                PC + 2              ; Eat the opcode
                FR = True

            Case #NS_op_load; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR = NS_flags(v1)
                PC + 2              ; Eat the parameter

            Case #NS_op_store; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NS_flags(v1) = FR
                PC + 2              ; Eat the parameter

            ; Logical operations
            Case #NS_op_and; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR AND NS_flags(v1)
                PC + 2              ; Eat the parameter

            Case #NS_op_or; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR OR NS_flags(v1)
                PC + 2              ; Eat the parameter

            Case #NS_op_not
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR = NOT NS_flags(v1)

            ; Flow control
            Case #NS_op_jump; offset
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC) - 1
                PC + (v1 ASL 1)

            Case #NS_op_jift; offset
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC) - 1
                if FR
                    PC + (v1 ASL 1)
                Else
                    PC + 2              ; Eat the parameter
                End If

            Case #NS_op_jiff; offset
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC) - 1
                if FR
                    PC + 2              ; Eat the parameter
                Else
                    PC + (v1 ASL 1)
                End If

            Case #NS_op_end
                PC = EOS

            ; Scene operations
            Case #NS_op_setbg; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                SC_set_bg{v1}
                PC + 2              ; Eat the parameter

            ; Shape operations
            Case #NS_op_draw; id x y
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                v2 = Peek.w (NS_data_ptr + PC + 2)
                v3 = Peek.w (NS_data_ptr + PC + 4)
                SH_draw{v1, v2, v3}
                PC + 6              ; Eat the parameters

            ; Inventory Operations
            Case #NS_op_hasi; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR = IV_has_item{v1}
                PC + 2              ; Eat the parameter

            Case #NS_op_addi; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                IV_add_item{v1}
                PC + 2              ; Eat the parameter

            Case #NS_op_remi; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                IV_remove_item{v1}
                PC + 2              ; Eat the parameter

            ; Game operations
            Case #NS_op_goto; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NN_game_set_scene{v1}
                PC = EOS

            Case #NS_op_map
                PC + 2              ; Eat the opcode
                NN_game_map{}
                PC = EOS

            Case #NS_op_text; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NN_display_text{v1}
                PC + 2              ; Eat the parameter

            Case #NS_op_gameover
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NN_game_over{v1}
                PC = EOS

            Default
                ; Unknown opcode!
                v1 = Peek.w (NS_data_ptr + PC)
                NPrint "*** Error! Unknown opcode!"
                NPrint "PC: ", PC, "    Opcode: ", v1
                PC = EOS

        End Select
    Until PC >= EOS
End Statement

Statement NS_DEBUG_print_bytecode{}
    SHARED NS_data_ptr, NS_data_size
    DEFTYPE .w num_entries
    num_entries = NS_data_size / SizeOf .w

    DEFTYPE .s v
    For i = 0 to num_entries - 1
        v = Right$(Hex$(Peek.w (NS_data_ptr + (i * SizeOf .w))), 4)

        If i MOD 4 = 3
            NPrint v, " "
        Else
            Print v, " "
        End If
    Next
End Statement

