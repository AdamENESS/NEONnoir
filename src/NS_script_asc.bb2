XINCLUDE "NS_opcodes.bb2"
XINCLUDE "NN_game.bb2"
XINCLUDE "IV_inventory.bb2"
XINCLUDE "SH_shapes.bb2"
XINCLUDE "SC_scene.bb2"

NEWTYPE.NS_script
    offset.w
    size.w
End NEWTYPE

DEFTYPE .l NS_data_ptr, NS_data_size, NS_specs_ptr
DEFTYPE .w NS_num_scripts

Dim NS_flags.b(256)

#NS_magic = $4E533031 ; 'NS01'

Function.b NS_initialize{bytecode_file$}
    SHARED NS_data_ptr, NS_data_size, NS_specs_ptr, NS_num_scripts

    If Exists(bytecode_file$) = 0
        NPrint "Bytecode file ", bytecode_file, " does not exist."
        Function Return False
    End If

    DEFTYPE .w id, num_scripts
    id = 0
    If ReadFile(id, bytecode_file$)
        FileInput id

        ; The file should have a NS01 in the first 4 bytes, 4E 53 30 31
        DEFTYPE .l magic
        ReadMem id, &magic, 4
        If magic <> #NS_magic
            NPrint bytecode_file, " is not a valid NoirScript bytecode file."
            Function Return False
        End If

        ; Next we see how many scripts are in this file
        DEFTYPE .l spec_size
        ReadMem id, &NS_num_scripts, 2
        spec_size = NS_num_scripts *  SizeOf .NS_script
        NS_specs_ptr = AllocMem(spec_size, $10000)
        ReadMem id, NS_specs_ptr, spec_size

        ; Exclude the 4 byte for the magic number, -2 for the number of scripts
        ; -spec_size for the script specifications
        NS_data_size = Lof(id) - 4 - 2 - spec_size
        NS_data_ptr = AllocMem(NS_data_size, $10000) ; Best available and clear
        ReadMem id, NS_data_ptr, NS_data_size

        CloseFile id
        PopInput
    End If

    Function Return True
End Function

; Executes the bytecode pointed to in the script
; Assumes the existence of this global data:
;   NS_data: Word array containing the opcodes to all the scrips
;   NS_flags: Byte array containing all of the game's flags
; And these global statements/functions
;   NN_game_over: Transition to game over screen
;   NN_display_text: Show text on the screen
;   IV_has_item: Check if an item is in the inventory
;   IV_add_item: Adds an item to the inventory
;   IV_remvoe_item: Removes and item from the inventory
;   SH_draw: Draws a shape
;   SC_set_bg: Sets the background in a scene
;   NN_game_set_scene: Goes to a new scene
;   NN_game_map: Display the map with locations
Statement NS_execute_script{script_id.w}
    SHARED NS_data_ptr, NS_flags()    ; get a reference to the script data and game flags
    SHARED NS_specs_ptr, NS_num_scripts


    ; Get the referenced script
    If script_id > NS_num_scripts
        NPrint "Script index", script_id, " out of bounds";
        Statement Return
    End If

    DEFTYPE .NS_script script
    DEFTYPE .l spec_ptr
    spec_ptr = script_id * SizeOf .NS_script
    CopyMem_ spec_ptr, &script, SizeOf .NS_script

    PC.w = script\offset             ; Set up program counter
    EOS.w = PC + script\size * 2  ; Figure out the end of script is
    FR.b = False                    ; Initialize Flag Register

    DEFTYPE .w v1, v2, v3
    Repeat
        Select Peek.w (NS_data_ptr + PC)
            Case #NS_op_noop
                PC + 2              ; Eat the opcode

            ; Flag register operations
            Case #NS_op_clear
                PC + 2              ; Eat the opcode
                FR = False

            Case #NS_op_set
                PC + 2              ; Eat the opcode
                FR = True

            Case #NS_op_load; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR = NS_flags(v1)
                PC + 2              ; Eat the parameter

            Case #NS_op_store; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NS_flags(v1) = FR
                PC + 2              ; Eat the parameter

            ; Logical operations
            Case #NS_op_and; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR AND NS_flags(v1)
                PC + 2              ; Eat the parameter

            Case #NS_op_or; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR OR NS_flags(v1)
                PC + 2              ; Eat the parameter

            Case #NS_op_not
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR = NOT NS_flags(v1)

            ; Flow control
            Case #NS_op_jump; offset
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC) - 1
                PC + (v1 ASL 1)

            Case #NS_op_jift; offset
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC) - 1
                if FR
                    PC + (v1 ASL 1)
                Else
                    PC + 2              ; Eat the parameter
                End If

            Case #NS_op_jiff; offset
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC) - 1
                if FR
                    PC + 2              ; Eat the parameter
                Else
                    PC + (v1 ASL 1)
                End If

            Case #NS_op_end
                PC = EOS

            ; Scene operations
            Case #NS_op_setbg; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                SC_set_bg{v1}
                PC + 2              ; Eat the parameter

            ; Shape operations
            Case #NS_op_draw; id x y
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                v2 = Peek.w (NS_data_ptr + PC + 2)
                v3 = Peek.w (NS_data_ptr + PC + 4)
                SH_draw{v1, v2, v3}
                PC + 6              ; Eat the parameters

            ; Inventory Operations
            Case #NS_op_hasi; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                FR = IV_has_item{v1}
                PC + 2              ; Eat the parameter

            Case #NS_op_addi; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                IV_add_item{v1}
                PC + 2              ; Eat the parameter

            Case #NS_op_remi; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                IV_remove_item{v1}
                PC + 2              ; Eat the parameter

            ; Game operations
            Case #NS_op_goto; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NN_game_set_scene{v1}
                PC = EOS

            Case #NS_op_map
                PC + 2              ; Eat the opcode
                NN_game_map{}
                PC = EOS

            Case #NS_op_text; id
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NN_display_text{v1}
                PC + 2              ; Eat the parameter

            Case #NS_op_gameover
                PC + 2              ; Eat the opcode
                v1 = Peek.w (NS_data_ptr + PC)
                NN_game_over{v1}
                PC = EOS

            Default
                ; Unknown opcode!
                v1 = Peek.w (NS_data_ptr + PC)
                NPrint "*** Error! Unknown opcode!"
                NPrint "PC: ", PC, "    Opcode: ", v1
                PC = EOS

        End Select
    Until PC >= EOS
End Statement

Statement NS_DEBUG_print_bytecode{}
    SHARED NS_data_ptr, NS_data_size
    DEFTYPE .w num_entries
    num_entries = NS_data_size / SizeOf .w

    DEFTYPE .s v
    For i = 0 to num_entries - 1
        v = Right$(Hex$(Peek.w (NS_data_ptr + (i * SizeOf .w))), 4)

        If i MOD 4 = 3
            NPrint v, " "
        Else
            Print v, " "
        End If
    Next
End Statement
