; =============================================================================
;                           _   _  _____ _____ _   _                           
;                          | \ | ||  ___|  _  | \ | |                          
;                          |  \| || |__ | | | |  \| |                          
;                          | . ` ||  __|| | | | . ` |                          
;                          | |\  || |___\ \_/ / |\  |                          
;                          \_| \_/\____/ \___/\_| \_/                          
;                         __   _  _____  _____  ______                          
;                         | \  | |     |   |   |_____/                          
;                         |  \_| |_____| __|__ |    \_                          
;
;                             A game by Massimo Loi
;                                   (c) 2022
; -----------------------------------------------------------------------------

WBStartup
DEFTYPE .w

; Enable/Disable debug logging
#DB_ENABLE_DEBUG_LOG = -1
#DB_ENABLE_DEBUG_TRACE = -1

; =============================================================================
; DB_log
; -----------------------------------------------------------------------------
; If in debug mode, logs values to WinUAE's debug window.
; Adapted from Deadalus, who did all the hard work.
;
; Define #DB_ENABLE_DEBUG_LOG = -1 to enable logging
; Define #DB_ENABLE_DEBUG_TRACE = -1 to enable trace logging
; -----------------------------------------------------------------------------
; WinUAE version 4.4.0+ required (tested on 4.9.1)
; Change these settings
;   * Settings/Hardware/ROM page: Set "Advanced Custom ROM settings" to "ROM #1"
;   * Settings/Host/Miscellaneous: Enable "Debug memory space"
;   * Settings/Paths: In "Debug logging", enable "Log window".
;       Note: This last one must be done every time as this setting is not 
;             saved. Make sure to do this before you start the Amiga, otherwise
;             this option will be disabled.
; =============================================================================

; Prints a string directly to the debug window
; Should not be called directly
; -----------------------------------------------------------------------------
Statement dbugprintstring{output$}
  output$ = "******** " + output$ + Chr$(10) ; Newline
  Poke.l $bfff04, &output$
End Statement

; Prints a format string that accepts one parameter
; Should not be call directly
; -----------------------------------------------------------------------------
Statement dbugprintval{fmt$, value.l}
  fmt$ = "******** " + fmt$ + Chr$(10)
  Poke.l $bfff00, value
  Poke.l $bfff04, &fmt$
End Statement

; Prints a string directly to the debug window
; Params:
;   `1: Tag
;   `2: String to log
;
; Usage:
;   !DB_log_str{"FONT", "loading font"}
; Output:
;   [FONT] loading font
; -----------------------------------------------------------------------------
Macro DB_log_str
CNIF #DB_ENABLE_DEBUG_LOG = -1
  dbugprintstring{(`1) + ": " + (`2)}
CEND
End Macro

; Prints a numeric value or format string
;
; Params:
;   `1: Tag
;   `2: Format string (Optional)
;   `3: Value
;
; Usage:
;   !DB_log_val{"CORE", "memory location $%lx", &pointer}
;   !DB_log_val{"CORE", &pointer}
; Output:
;   [CORE] memory location $404BED28
;   [CORE] 1078717736
; -----------------------------------------------------------------------------
Macro DB_log_val
CNIF #DB_ENABLE_DEBUG_LOG = -1
  CNIF `0=2
    dbugprintval{(`1) + ": %ld", (`2)}
  CELSE
    dbugprintval{(`1) + ": " + (`2), (`3)}
  CEND
CEND
End Macro

; Prints out text only if tracing is enabled. This is meant to trace out
; statement, functions, gosubs, etc. and is meant to be able to be 
; disabled without disablying all logging.
;
; Parameters:
;   Filename/Tag
;   Function/Statement/Code section name
;
; Usage:
;   !DB_trace{"main", "load_data"} ; load_data function in main.bb2
; Outputs:
;   [TRACE - main] load_data
; -----------------------------------------------------------------------------
Macro DB_trace
CNIF #DB_ENABLE_DEBUG_LOG = -1
  CNIF #DB_ENABLE_DEBUG_TRACE = -1
    dbugprintstring{"[TRACE - " + (`1) + "] " + (`2)}
  CEND
CEND
End Macro

; Simple printf implementation.
; Other than the format string, it cannot use string literals.
; String params should be preceeded with &, ie &foo$
; -----------------------------------------------------------------------------
Macro DB_printf
  CNIF #DB_ENABLE_DEBUG_LOG = -1
    CNIF `0 > 1
      Poke.l $BFFF00, (`2)
    CEND

    CNIF `0 > 2
      Poke.l $BFFF00, (`3)
    CEND

    CNIF `0 > 3
      Poke.l $BFFF00, (`4)
    CEND

    CNIF `0 > 4
      Poke.l $BFFF00, (`5)
    CEND

    CNIF `0 > 5
      Poke.l $BFFF00, (`6)
    CEND

    printf_fmt$ = (`1) + Chr$(10)
    Poke.l $BFFF04, &printf_fmt$
  CEND
End Macro

Macro DB_warn
  CNIF #DB_ENABLE_DEBUG_LOG = -1
    dbugprintstring{(`1) + ": **WARNING** " + (`2)}
  CEND
End Macro

Macro DB_error
  CNIF #DB_ENABLE_DEBUG_LOG = -1
    dbugprintstring{(`1) + ": **ERROR** " + (`2)}
  CEND
End Macro
; =============================================================================
; NN_core
; -----------------------------------------------------------------------------
; Contains all global variables and a means to initialize and uninitialize that
; data
; =============================================================================

; =============================================================================
; Define all game types
; =============================================================================

; Regions
; -----------------------------------------------
NEWTYPE .NN_region
  x1.w
  y1.w
  x2.w
  y2.w
  pointer_id.w
  description_id.w
  script_offset.w
End NEWTYPE

; Scene
; -----------------------------------------------
NEWTYPE.NN_scene
  name_id.w
  on_enter.w
  on_exit.w
  background_id.w
  first_region.w
  last_region.w
End NEWTYPE

; Location
; -----------------------------------------------
NEWTYPE .NN_location
  name_id.w
  first_bg.w
  last_bg.w
  first_scene.w
  last_scene.w
End NEWTYPE

; Dialogue Choice
; -----------------------------------------------
NEWTYPE .DG_choice
  text_id.w           ; index into string table
  set_flag.w          ; set this flag on selection, $FFFF if none
  check_flag.w        ; flag that determines if criteria is met, $FFFF if none
  page_id.w           ; id to the next page in the conversation
  script_offset.w     ; script to run if selected, $FFFF if none
  enabled.b           ; determine if it should be shown. If this is False, 
                      ; it overrides the flag property
  self_disable.b      ; Disable itself if true
End NEWTYPE

; Dialogue Page
; -----------------------------------------------
NEWTYPE .DG_page
  text_id.w           ; index into string array, $FFFF if no text
  set_flag.w          ; set this flag on selection, $FFFF if none
  check_flag.w        ; flag that determines if criteria is met, $FFFF if none
  page_id.w           ; index to the next page to display, $FFFF if no page
  first_choice_id.w   ; id of the first choice
  choice_count.w      ; number of choices in the page
  enabled.b           ; determine if it should be shown.
  self_disable.b      ; Disable itself if true
End NEWTYPE

; Dialogue
; -----------------------------------------------
NEWTYPE .DG_dialogue
  first_page_id.w     ; id of the first page of dialogue
  page_count.w        ; number of page in the dialogue
  speaker_name.w      ; text id for the speaker's name
  speaker_image.w     ; shape id for the speaker's portrait
End NEWTYPE

NEWTYPE .NN_word
  start_idx.w
  end_idx.w
End NEWTYPE

; Misc
; -----------------------------------------------
NEWTYPE .NN_screen_rect
  x0.w
  y0.w
  x1.w
  y1.w
End NEWTYPE

; =============================================================================
; Define all globals and macros
; =============================================================================

; NN_region dynamic array
; -----------------------------------------------
DEFTYPE .NN_region *NN_regions, *NN_current_region
DEFTYPE .l NN_region_count

Macro __get_region
  (*NN_regions + (SizeOf .NN_region * (`1)))
End Macro

; NN_scene dynamic array
; -----------------------------------------------
DEFTYPE .NN_scene *NN_scenes, *NN_current_scene
DEFTYPE .l NN_scene_count

Macro __get_scene
  (*NN_scenes + (SizeOf .NN_scene * (`1)))
End Macro

; NN_location dynamic array
; -----------------------------------------------
DEFTYPE .NN_location *NN_locations, *NN_current_location
DEFTYPE .l NN_location_count

Macro __get_location
  (*NN_locations + (SizeOf .NN_location * (`1)))
End Macro

; DG_choice dynamic array
; -----------------------------------------------
DEFTYPE .DG_choice *DG_choices
DEFTYPE .l DG_choice_count

Macro __get_choice
  (*DG_choices + (SizeOf .DG_choice * (`1)))
End Macro

; DG_page dynamic array
; -----------------------------------------------
DEFTYPE .DG_page *DG_pages
DEFTYPE .l DG_page_count

Macro __get_page
  (*DG_pages + (SizeOf .DG_page * (`1)))
End Macro

; DG_dialogue dynamic array
; -----------------------------------------------
DEFTYPE .DG_dialogue *DG_dialogues
DEFTYPE .l DG_dialogue_count

Macro __get_dialogue
  (*DG_dialogues + (SizeOf .DG_dialogue * (`1)))
End Macro

; String Table
; -----------------------------------------------
DEFTYPE .w *NN_string_table
DEFTYPE .b *NN_string_data
DEFTYPE .l NN_string_count, NN_string_data_size

Macro __get_string_length
  (Peek.w (*NN_string_table + ((`1) * SizeOf .l)))
End Macro

Macro __get_string_addr
  (Peek.l (*NN_string_table + ((`1) * SizeOf .l)) + 4)
End Macro

Macro __get_string
  Peek$(!__get_string_addr{(`1)})
End Macro

; Word Table/Data
; Stores the position of the beginning and end of every work in every string
; -----------------------------------------------
DEFTYPE .l *NN_word_table, NN_word_table_count, NN_word_data_size
DEFTYPE .NN_word *NN_word_data

Macro __get_word_count
  (Peek.l(Peek.l (*NN_word_table + ((`1) * SizeOf .l))))
End Macro

Macro __get_words
  (Peek.l (*NN_word_table + ((`1) * SizeOf .l)) + 4)
End Macro

; Script
; -----------------------------------------------
DEFTYPE .w *NS_script_data, NS_script_queue
DEFTYPE .l NS_script_data_size

Dim NS_flags.b(256)
; -----------------------------------------------
DEFTYPE .b DG_dialogue_is_active, DB_active_dialogue

; Dialogue

; Inventory
; -----------------------------------------------
; Inventory items in the player's possessions
; 32 is probably enough
#IV_max_items = 32
Dim List IV_user_items(#IV_max_items)

; Main
; -----------------------------------------------
DEFTYPE .b NN_current_bmp
DEFTYPE .b NN_should_quit

; =============================================================================
; Convenience Macros
; =============================================================================
Macro __use_string_table
  SHARED *NN_string_table
End Macro

Macro __use_word_table
  SHARED *NN_word_table
End Macro

Macro __use_dialogues
  SHARED *DG_dialogues, *DG_pages, *DG_choices
End Macro

Macro __use_dialogue_limits
  SHARED DG_dialogue_count, DG_page_count, DG_choice_count
End Macro

Macro __make_size
  ((`1) LSL 16) + (`2)
End Macro

Macro __get_size_width
  (`1) LSR 16
End Macro

Macro __get_size_height
  (`1) AND $0000FFFF
End Macro

; =============================================================================
; Constants
; =============================================================================

; Game resolution
; -----------------------------------------------------------------------------
#NN_screen_width = 320
#NN_screen_height = 200
#NN_screen_bpp = 8
#NN_screen_colors = 256

#NN_half_screen_width = #NN_screen_width / 2

; Coplist
#CP_coplist = 0
#CP_origin = 44
#CP_sprites = 8

#CP_flag_agamode = $10000
#CP_flag_8bit = $8

#CP_flags = #CP_flag_agamode + #CP_flag_8bit

; Main bitmap and main palette
#BMP_main = 0
#PAL_main = 0
#PAL_fx = 10
; Display buffer
#BF_main_screen = 0


; Loading NEONpacks
; -----------------------------------------------------------------------------
#NN_NEON_magic = $4E454F4E     ; NEON
#NN_NEON_locs = $4C4F4352     ; LOCS
#NN_NEON_scns = $53424E53     ; SCNS
#NN_NEON_rngs = $52474E53     ; RGNS
#NN_NEON_dlgs = $444C4753     ; DLGS
#NN_NEON_page = $50414745     ; PAGE
#NN_NEON_chce = $43484245     ; CHCE
#NN_NEON_byte = $42595445     ; BYTE
#NN_NEON_strg = $53545247     ; STRG

#NN_NEON_success                = -1
#NN_NEON_file_not_found         = 1
#NN_NEON_generic_read_error     = 2
#NN_NEON_not_a_neon_file        = 3
#NN_NEON_version_not_supported  = 4

; Mouse pointers
; -----------------------------------------------------------------------------
#NN_pointer_start = 10
#NN_pointer_end = 13
#NN_pointer_default = 10
#NN_pointer_examine = 11
#NN_pointer_interact = 12
#NN_pointer_exit = 13

; Text
; -----------------------------------------------------------------------------
#TX_font_start = 32
#TX_font_end = 127
#TX_frame_start = 22
#TX_frame_end = 30
#TX_char_per_line = 28
#TX_lines_per_frame = 2

; Shape ids for the 9-patch for the text frame
#TX_frame_tl = 22
#TX_frame_tm = 23
#TX_frame_tr = 24
#TX_frame_ml = 25
#TX_frame_mm = 26
#TX_frame_mr = 27
#TX_frame_bl = 28
#TX_frame_bm = 29
#TX_frame_br = 30

#TX_frame_size = 8
#TX_frame_total_size = 16

; This is specific to the font file we're using
; A more robust approach would be to read this from a file
#TX_font_width = 6
#TX_font_height = 8

#TX_scratch_bmp = 10
#TX_space = 32
#TX_newline = 10
#TX_text_shape = 21
; =============================================================================
; NN_utils
; -----------------------------------------------------------------------------
; Various game utilities
; =============================================================================

DEFTYPE .b IN_prev_state
IN_prev_state = 0

#IN_mouse_none = 0
#IN_mouse_pressed = 1
#IN_mouse_released = 2
#IN_mouse_held = 3

Function .b IN_update_mouse{}
  SHARED IN_prev_state

  curr.b = Joyb(0) AND %0001   ; Isolate left mouse button
  prev.b = IN_prev_state
  IN_prev_state = curr

  ; The possible mouse states
  ; Prev | Curr | Meaning
  ;    0 |    0 | None
  ;    0 |    1 | Pressed
  ;    1 |    0 | Released
  ;    1 |    1 | Held
  value.b = (prev LSL 1) OR (curr)
;  !DB_printf{"*********** prev %d - curr %d = value %d", prev, curr, value}
  Function Return value
End Function

BLITZ

Function .b IN_check_mouse{screen_rects.l, count.w}
  DEFTYPE .NN_screen_rect *rect
  DEFTYPE .b result
  DEFTYPE .w x, y

  x = MouseX
  y = MouseY
  result = -1

  ;!DB_printf{"Mouse Pos (%d, %d)", x, y}

  *rect = screen_rects
  For r = 0 To count - 1
    ;!DB_printf{"    rect %d: %d,%d %d,%d", r,  *rect\x0, *rect\y0, *rect\x1, *rect\y1}
    If x >= *rect\x0 AND x < *rect\x1 AND y >= *rect\y0 AND y < *rect\y1
      ; DEFTYPE .w x0, x1, y0, y1
      ; x0 =  *rect\x0
      ; x1 =  *rect\x1
      ; y0 =  *rect\y0
      ; y1 =  *rect\y1
      ; Box x0, y0, x1, y1, 2
      Function Return r
    End If

    *rect + (SizeOf .NN_screen_rect)
  Next

  Function Return result
End Function

Statement FadeInScreen{cop, source, dest}
  InitPalette dest, 256
  For i = 25 To 0 Step -1
    FadePalette source, dest, 1-i/25
    VWait
    DisplayPalette cop, dest
  Next
End Statement

Statement FadeOutScreen{cop, source, dest}
  InitPalette dest, 256
  For i = 0 To 25
    FadePalette source, dest, 1-i/25
    VWait
    DisplayPalette cop, dest
  Next
End Statement

AMIGA
; =============================================================================
; NN_game
; -----------------------------------------------------------------------------
; Contains functions an statement around running the game
; =============================================================================

Statement DEBUG_print_words{}
  !__use_string_table{}
  !__use_word_table{}
  SHARED NN_string_count

  Stop

  For i = 0 To NN_string_count - 1
    Print !__get_string{i}
    Print ":"

    word_count = !__get_word_count{i}
    !DB_printf{"Iteration %d. %d words", i, word_count}
    DEFTYPE .NN_word *word
    *word = !__get_words{i}
    For j = 0 to word_count - 1

      !DB_printf{"    *word address: %ld, expected %ld", *word, Peek.l(*NN_word_table + (i * SizeOf .l)) + 4}
      !DB_printf{"    start %d, end %d", *word\start_idx, *word\end_idx}
      Print Right$(Hex$(*word\start_idx), 4), "-", Right$(Hex$(*word\end_idx), 4)," "
      *word + SizeOf .NN_word
    Next j

    NPrint ""
  Next i

  Stop
End Statement

; Loads a neon pack
;
; Requires AMIGA or QAMIGA mode
; =============================================================================
Function .b NN_load_neonpack{filename$}
  SHARED *NN_locations, *NN_scenes, *NN_regions, *NN_string_table, *NN_string_data
  SHARED NN_location_count, NN_scene_count, NN_region_count, NN_string_count, NN_string_data_size
  SHARED *NS_script_data, NS_script_data_size
  SHARED *NN_word_table, NN_word_table_count, NN_word_data_size, *NN_word_data
  !__use_dialogues{}
  !__use_dialogue_limits{}


  !DB_trace{"NN_GAME", "NN_load_neonpack: " +  filename$}

  If Exists(filename$) = 0 Then Function Return #NN_NEON_file_not_found

  DEFTYPE .w id
  id = 0
  If ReadFile(id, filename$) = 0 Then Function Return #NN_NEON_generic_read_error

  FileInput id

  ; Read the header
  DEFTYPE .l magic
  ReadMem id, &magic, 4
  If magic <> #NN_NEON_magic Then Function Return #NN_NEON_not_a_neon_file

  ; Read the version -- Support only v1.0
  DEFTYPE .l version
  ReadMem id, &version, 4
  If version <> $00010000 Then Function Return #NN_NEON_version_not_supported

  ; Read in all the locations
  DEFTYPE .l size, header
  ReadMem id, &header, 4
  ReadMem id, &NN_location_count, 4
  size = NN_location_count * SizeOf .NN_location
  *NN_locations = AllocMem_(size, $10000)  ; Best available memory and clear
  ReadMem id, *NN_locations, size
  !DB_log_str{"NN_GAME", "    Locations > Addr: $" + Hex$(*NN_locations) + " Size: " + Str$(size)}

  ; Read in all the scenes
  ReadMem id, &header, 4
  ReadMem id, &NN_scene_count, 4
  size = NN_scene_count * SizeOf .NN_scene
  *NN_scenes = AllocMem_(size, $10000)  ; Best available memory and clear
  ReadMem id, *NN_scenes, size
  !DB_log_str{"NN_GAME", "    Scenes    > Addr: $" + Hex$(*NN_scenes) + " Size: " + Str$(size)}

  ; Read in all the regions
  ReadMem id, &header, 4
  ReadMem id, &NN_region_count, 4
  size = NN_region_count * SizeOf .NN_region
  *NN_regions = AllocMem_(size, $10000)  ; Best available memory and clear
  ReadMem id, *NN_regions, size
  !DB_log_str{"NN_GAME", "    Regions   > Addr: $" + Hex$(*NN_regions) + " Size: " + Str$(size)}

  ; Read all dialogues
  ReadMem id, &header, 4
  ReadMem id, &DG_dialogue_count, 4
  size = DG_dialogue_count * SizeOf .DG_dialogue
  *DG_dialogues = AllocMem_(size, $10000)
  ReadMem id, *DG_dialogues, size
  !DB_log_str{"NN_GAME", "    Dialogues > Addr: $" + Hex$(*DG_dialogues) + " Size: " + Str$(size)}

  ; Read all pages
  ReadMem id, &header, 4
  ReadMem id, &DG_page_count, 4
  size = DG_page_count * SizeOf .DG_page
  *DG_pages = AllocMem_(size, $10000)
  ReadMem id, *DG_pages, size
  !DB_log_str{"NN_GAME", "    Pages     > Addr: $" + Hex$(*DG_pages) + " Size: " + Str$(size)}

  ; Read all choices
  ReadMem id, &header, 4
  ReadMem id, &DG_choice_count, 4
  size = DG_choice_count * SizeOf .DG_choice
  *DG_choices = AllocMem_(size, $10000)
  ReadMem id, *DG_choices, size
  !DB_log_str{"NN_GAME", "    Choices   > Addr: $" + Hex$(*DG_choices) + " Size: " + Str$(size)}

  ; Read all the bytecode... I suppose it's more like word-code
  ReadMem id, &header, 4
  ReadMem id, &NS_script_data_size, 4
  NS_script_data_size * SizeOf .w
  *NS_script_data = AllocMem_(NS_script_data_size, $10000)
  ReadMem id, *NS_script_data, NS_script_data_size
  !DB_log_str{"NN_GAME", "    Script    > Addr: $" + Hex$(*NS_script_data) + " Size: " + Str$(NS_script_data_size)}

  ; Read all the strings and generate a string table
  ReadMem id, &header, 4
  ReadMem id, &NN_string_count, 4
  ReadMem id, &NN_string_data_size, 4
  *NN_string_table = AllocMem_(NN_string_count * SizeOf .l, $10000)
  *NN_string_data = AllocMem_(NN_string_data_size, $10000)
  !DB_log_str{"NN_GAME", "    Str Table > Addr: $" + Hex$(*NN_string_table) + " Size: " + Str$(NN_string_count * SizeOf .l)}
  !DB_log_str{"NN_GAME", "    Str Data  > Addr: $" + Hex$(*NN_string_data) + " Size: " + Str$(NN_string_data_size)}

  DEFTYPE .l ptr
  ptr = *NN_string_data
  DEFTYPE .l string_size
  For i = 0 To NN_string_count - 1
    Poke.l *NN_string_table + (i * 4), ptr

    ReadMem id, &string_size, 4
    Poke.l ptr, string_size

    ptr + 4
    ReadMem id, ptr, string_size

    ptr + string_size
  Next

  ; Read all the word separations and generate a words list table
  ReadMem id, &header, 4
  ReadMem id, &NN_word_table_count, 4
  ReadMem id, &NN_word_data_size, 4
  *NN_word_table = AllocMem_(NN_word_table_count * SizeOf .l, $10000)
  *NN_word_data = AllocMem_(NN_word_data_size, $10000)
  !DB_log_str{"NN_GAME", "    Wrd Table > Addr: $" + Hex$(*NN_word_table) + " Size: " + Str$(NN_word_table_count * SizeOf .l)}
  !DB_log_str{"NN_GAME", "    Word Data  > Addr: $" + Hex$(*NN_word_data) + " Size: " + Str$(NN_word_data_size)}

  ptr = *NN_word_data
  DEFTYPE .l word_list_size
  For i = 0 To NN_word_table_count - 1
    Poke.l *NN_word_table + (i * 4), ptr

    ReadMem id, &word_list_size, 4
    Poke.l ptr, word_list_size

    ptr + 4
    ReadMem id, ptr, word_list_size * SizeOf .NN_word

    ptr + word_list_size * SizeOf .NN_word
  Next

  Function Return #NN_NEON_success
End Function

; Frees up all allocated memory
; =============================================================================
Statement NN_uninitialize{}
  !DB_trace{"NN_GAME", "NN_uninitialize"}
  SHARED *NN_locations, *NN_scenes, *NN_regions, *NN_string_table, *NN_string_data
  SHARED NN_location_count, NN_scene_count, NN_region_count, NN_string_count, NN_string_data_size
  SHARED *NS_script_data, NS_script_data_size
  SHARED *NN_word_table, *NN_word_data, NN_word_table_count, NN_word_data_size
  !__use_dialogues{}
  !__use_dialogue_limits{}

  FreeMem_ *NN_locations, SizeOf .NN_location * NN_location_count
  !DB_log_str{"NN_GAME", "    FreeMem locations $" + Hex$(*NN_locations) + ", " + Str$(SizeOf .NN_location * NN_location_count)}

  FreeMem_ *NN_scenes, SizeOf .NN_scene * NN_scene_count
  !DB_log_str{"NN_GAME", "    FreeMem scenes    $" + Hex$(*NN_scenes) + ", " + Str$(SizeOf .NN_scene * NN_scene_count)}

  FreeMem_ *NN_regions, SizeOf .NN_region * NN_region_count
  !DB_log_str{"NN_GAME", "    FreeMem regions   $" + Hex$(*NN_regions) + ", " + Str$(SizeOf .NN_region * NN_region_count)}

  FreeMem_ *DG_dialogues, SizeOf .DG_dialogue * DG_dialogue_count
  !DB_log_str{"NN_GAME", "    FreeMem dialogues $" + Hex$(*DG_dialogues) + ", " + Str$(SizeOf .DG_dialogue * DG_dialogue_count)}

  FreeMem_ *DG_pages, SizeOf .DG_page * DG_page_count
  !DB_log_str{"NN_GAME", "    FreeMem pages     $" + Hex$(*DG_pages) + ", " + Str$(SizeOf .DG_page * DG_page_count)}

  FreeMem_ *DG_choices, SizeOf .DG_choice * DG_choice_count
  !DB_log_str{"NN_GAME", "    FreeMem choices   $" + Hex$(*DG_choices) + ", " + Str$(SizeOf .DG_choice * DG_choice_count)}

  FreeMem_ *NS_script_data, NS_script_data_size
  !DB_log_str{"NN_GAME", "    FreeMem str data  $" + Hex$(*NS_script_data) + ", " + Str$(NS_script_data_size)}

  FreeMem_ *NN_string_table, SizeOf .l * NN_string_count
  !DB_log_str{"NN_GAME", "    FreeMem str table $" + Hex$(*NN_string_table) + ", " + Str$(SizeOf .l * NN_string_count)}

  FreeMem_ *NN_string_data, NN_string_data_size
  !DB_log_str{"NN_GAME", "    FreeMem str data  $" + Hex$(*NN_string_data) + ", " + Str$(NN_string_data_size)}

  FreeMem_ *NN_word_table, SizeOf .l * NN_word_table_count
  !DB_log_str{"NN_GAME", "    FreeMem wrd table $" + Hex$(*NN_word_table) + ", " + Str$(SizeOf .l * NN_word_table_count)}

  FreeMem_ *NN_word_data, NN_word_data_size
  !DB_log_str{"NN_GAME", "    FreeMem wrd data  $" + Hex$(*NN_word_data) + ", " + Str$(NN_word_data_size)}
End Statement

; Loads the mouse pointers
;
; Requires AMIGA or QAMIGA mode
; =============================================================================
Statement NN_load_pointers{filename$}
  !DB_trace{"NN_GAME", "NN_load_pointers"}
  LoadShapes #NN_pointer_start, #NN_pointer_end, filename$

  SpriteMode 0
  For i = #NN_pointer_start To #NN_pointer_end
    GetaSprite i - #NN_pointer_start, i
    Free Shape i
  Next
End Statement

; Initializes the game resources
; neonpack$: Game's .NEON file, relative to the data/ directory
; pointers$: Game's mouse cursors, relative to the data/ directory
; =============================================================================
Function NN_initialize{neonpack$, pointers$}
  !DB_trace{"NN_GAME", "NEONpack: " + neonpack$ + " Mouse Pointers: " + pointers$}
  NN_load_pointers{"data/" + pointers$}

  Function Return NN_load_neonpack{"data/" + neonpack$}
End Function

; Loads the bitmaps for the new location and set the current
; scene to the selected one.
;
; Requires AMIGA or QAMIGA mode
; =============================================================================
Statement NN_load_location{new_loc_id.w, new_scene_id.w}
  !DB_trace{"NN_GAME", "NN_load_location{" + Str$(new_loc_id) + ", " + Str$(new_scene_id) + "}"}
  SHARED *NN_current_location, *NN_current_scene
  SHARED *NN_locations, *NN_scenes, *NN_string_table, *NN_string_data
  *NN_current_location = !__get_location{new_loc_id}

  ; Load all the backgrounds
  For bg = 0 To *NN_current_location\last_bg - *NN_current_location\first_bg
    BitMap bg, #NN_screen_width, #NN_screen_height, #NN_screen_bpp
    bmp$ = !__get_string{bg + *NN_current_location\first_bg}
    LoadBitMap bg, "data/" + bmp$, bg
  Next

  ;BLITZ
  ; Setup the next scene
  *NN_current_scene = !__get_scene{*NN_current_location\first_scene + new_scene_id}
  ; If *NN_current_scene\on_enter <> -1
  ;   NS_execute_script{*NN_current_scene\on_enter}
  ; End If
End Statement


; Checks if a point is inside one of the regions
; =============================================================================
Function.w NN_get_overlapped_region{mx.w, my.w}
  ;!DB_trace{"NN_GAME", "NN_get_overlapped_region"}
  SHARED *NN_regions, *NN_current_scene
  DEFTYPE .NN_region *region

  For r = *NN_current_scene\first_region To *NN_current_scene\last_region
    *region = !__get_region{r}
    x1.w = *region\x1
    x2.w = *region\x2
    y1.w = *region\y1
    y2.w = *region\y2

    If mx >= x1 AND mx < x2 AND my >= y1 AND my < y2
      Function Return r
    End If
  Next

  Function Return -1
End Function

; Sets the currently selected scene
; =============================================================================
Statement NN_game_set_scene{id.w}
  SHARED *NN_scenes, *NN_current_scene, NN_current_bmp, *NN_current_location
  !DB_trace{"NN_GAME", "NN_game_set_scene: " + Str$(id)}

  ; If *NN_current_scene\on_exit <> -1
  ;   NS_execute_script{*NN_current_scene\on_exit}
  ; End If

  FadeOutScreen{ #CP_coplist, NN_current_bmp, 10}
  *NN_current_scene = !__get_scene{*NN_current_location\first_scene + id}

  ; If *NN_current_scene\on_enter <> -1
  ;   NS_execute_script{*NN_current_scene\on_enter}
  ; End If

  ;NN_current_bmp = *NN_current_scene\background_id

  ;FadeInScreen{ #CP_coplist, NN_current_bmp, 10}

End Statement

Statement NN_game_map{}
  !DB_trace{"NN_GAME", "NN_game_map"}
  NPrint "Displaying location map"
End Statement

Statement NN_game_over{id.w}
  !DB_trace{"NN_GAME", "NN_game_over"}
End Statement

Statement NN_quit_game{}
  SHARED NN_should_quit
  NN_should_quit = True
End Statement
; =============================================================================
; TX_core
; -----------------------------------------------------------------------------
; Text display functions
; Prefix TX = Text facilities
;
; Needs two Buffers, 0 and 1. Buffer 0 draws the frame and text
; while draws the blinking caret.
;

#primary = 0

DEFTYPE .w TX_frame_x, TX_frame_y

Statement TX_initialize{fontfile$, framefile$}
  !DB_trace{"TX_CORE", "TX_initialize: " + fontfile$ + ", " + framefile$}
  SHARED TX_frame_x, TX_frame_y
  LoadShapes #TX_font_start, #TX_font_end, "data/" + fontfile$
  LoadShapes #TX_frame_start, #TX_frame_end, "data/" + framefile$
End Statement

Statement TX_uninitialize{}
  !DB_trace{"TX_CORE", "TX_uninitialize"}
  For s = #TX_font_start To #TX_font_end
    Free Shape s
  Next

  For s = #TX_frame_start To #TX_frame_end
    Free Shape s
  Next
End Statement

BLITZ

Statement TX_draw_single_line{text$}
    !DB_trace{"TX_CORE", "TX_draw_single_line: " + text$}
    SHARED *NN_string_table, TX_frame_x, TX_frame_y
    DEFTYPE .l strloc, strlen
    DEFTYPE .w x, y, width

    strlen = Len(text$)

    width = strlen * #TX_font_width

    ; Center the text in the frame
    x = TX_frame_x - (width LSR 1)
    y = TX_frame_y - (#TX_font_height LSR 1)

    ;BBlit 0, #TX_frame_id, TX_frame_x, TX_frame_y, %0

    For i = 1 To strlen
        BBlit 0, Asc(Mid$(text$, i, 1)), x, y, %0
        x + #TX_font_width
    Next

    tick.w = 0

    ; Blink the caret
    Repeat
        If tick MOD 2 = 0
            BBlit 1, 127, x + #TX_font_width, y, %0
        Else
            UnBuffer 1
        End If

        tick + 1
        VWait 10
    Until Joyb(0) = 1

    ; Remove the text
    UnBuffer 0
End Statement

Statement TX_draw_text{text$, x.w, y.w}
  !DB_trace{"TX_CORE", "TX_draw_text: " + text$ + " " + Str$(x) + "," + Str$(y)}
  DEFTYPE .w width, strlen

  strlen = Len(text$)
  width = strlen * #TX_font_width

  If x + width > #NN_screen_width Then x = #NN_screen_width - width
  If y + #TX_font_height > DispHeight Then y = DispHeight - #TX_font_height

  For i = 0 To strlen - 1
    BBlit 0, Peek.b (&text$ + i), x, y, %0
    x + #TX_font_width
  Next
End Statement

Statement TX_draw_text_centered{text$, cx.w, cy.w}
  DEFTYPE .w width, halfw, halfh, strlen, x

  strlen = Len(text$)
  width = strlen * #TX_font_width
  halfw = width LSR 1
  halfh = #TX_font_height LSR 1

  If cx - halfw < 0 Then cx = halfw
  If cx + halfw >= #NN_screen_width Then cx = #NN_screen_width - halfw
  If cy - halfh < 0 Then cy = halfh
  If cy + halfh >= #NN_screen_width Then cy = #NN_screen_width - halfh

  x = cx - halfw
  For i = 0 To strlen - 1
    BBlit 0, Peek.b (&text$ + i), x, cy, %0
    x + #TX_font_width
  Next
End Statement

#TX_max_words = 64 ; Assume no more than 64 words in one go
Dim tx_word_begin.w(#TX_max_words)
Dim tx_word_end.w(#TX_max_words)
DEFTYPE .w tx_word_count

BLITZ

; [INTERNAL]
; Breaks a string into words, placing the beginning and ending of each word
; in the tx_word_begin and tx_word_end global arrays.
; =============================================================================
Statement tx_get_words{text$}
  !DB_trace{"TX_CORE", "tx_get_words"}
  SHARED tx_word_begin(), tx_word_end(), tx_word_count
  DEFTYPE .w begin, current, text_len

  ; Find the beginning and ends of every word
  tx_word_count = 0
  text_len = Len(text$)
  For begin = 1 To text_len
    current = begin
    While current < text_len AND Peek.b (&text$ + current) <> #TX_space
      current + 1 ; skip the space
    Wend

    tx_word_begin(tx_word_count) = begin - 1
    tx_word_end(tx_word_count) = current - 1
    tx_word_count + 1
    begin = current + 1; skip the space
  Next
End Statement

; [INTERNAL]
; Used to draw a frame around the text
; =============================================================================
Statement tx_draw_frame{line_width.w, line_count.w}
  !DB_trace{"TX_CORE", "tx_draw_frame: " + Str$(line_width) + ", " + Str$(line_count)}
  ; Top
  Blit #TX_frame_tl, 0, 0, 0
  DEFTYPE .w x
  x = #TX_frame_size
  For i = 1 To line_width
    Blit #TX_frame_tm, x, 0, 0
    x + #TX_font_width
  Next
  Blit #TX_frame_tr, x, 0, 0

  ; Middle
  For i = 1 To line_count
    Blit #TX_frame_ml, 0, #TX_font_height * i, 0
    Blit #TX_frame_mr, x, i * #TX_font_height, 0
  Next i

  ; Bottom
  Blit #TX_frame_bl, 0, #TX_font_height * (line_count + 1), 0
  x = #TX_frame_size
  For i = 1 To line_width
    Blit #TX_frame_bm, x, #TX_font_height * (line_count + 1), 0
    x + #TX_font_width
  Next
  Blit #TX_frame_br, x, #TX_font_height * (line_count + 1), 0
End Statement

; Draws a multiline string wrapped a given width. The text is drawn around a
; center point.
; =============================================================================
Statement TX_draw_text_wrapped{text$, line_width.w, cx.w, cy.w}
  !DB_trace{"TX_CORE", "TX_draw_text_wrapped: " + text$ + " " + Str$(line_width) + ", " + Str$(x) + "," + Str$(y)}
  SHARED tx_word_begin(), tx_word_end(), tx_word_count, NN_current_bmp
  DEFTYPE .w widthw, line_count
  DEFTYPE .w remaining
  DEFTYPE .w x0, y0, x, y, widthr, heightr, max_len, cur_len

  BitMap #TX_scratch_bmp, #NN_screen_width, #NN_screen_height, #NN_screen_bpp
  Use BitMap #TX_scratch_bmp

  ; Find the beginning and ends of every word
  tx_get_words{text$}

  ; Figure out how many lines it's going to be amd what's the size of the longest line
  remaining = line_width
  line_count = 1
  For i = 0 To tx_word_count - 1
    widthw = tx_word_end(i) - tx_word_begin(i) + 1

    If remaining - widthw < 0
      ; Advance To Next Line
      line_count + 1
      remaining = line_width
      cur_len = 0
    End If

    remaining - (widthw + 1) ; account for the space
    cur_len + widthw + 1
    If cur_len > max_len Then max_len = cur_len
  Next i

  If max_len < line_width Then line_width = max_len

  ; Calculate how big a rectangle this will be, including enough
  ; padding for the text frame
  widthr = line_width * #TX_font_width + #TX_frame_total_size
  heightr = line_count * #TX_font_height + #TX_frame_total_size
  x0 = #TX_frame_size
  y0 = #TX_frame_size

  ; Draw the frame
  ; Text area
  Boxf x0, y0, x0 + widthr - #TX_frame_total_size, y0 + heightr - #TX_frame_total_size, 3
  tx_draw_frame{line_width, line_count}

  ; Finally draw the text
  remaining = line_width
  x = x0
  y = y0
  For i = 0 To tx_word_count - 1
    widthw = tx_word_end(i) - tx_word_begin(i) + 1

    If remaining - widthw < 0
      ; Advance to next line
      x = x0
      y + #TX_font_height
      remaining = line_width
    End If

    ; Print the word
    For j = tx_word_begin(i) To tx_word_end(i)
      Blit Peek.b(&text$ + j), x, y, %0
      x + #TX_font_width
    Next j

    remaining - (widthw + 1) ; account for the space
    x + #TX_font_width
  Next i

  GetaShape #TX_text_shape, 0, 0, widthr, heightr
  MidHandle #TX_text_shape
  Use BitMap NN_current_bmp

  DEFTYPE .w halfw, halfh
  halfw = widthr LSR 1
  halfh = heightr LSR 1

  If cx - halfw < 0 Then cx = halfw
  If cx + halfw >= #NN_screen_width Then cx = #NN_screen_width - halfw
  If cy - halfh < 0 Then cy = halfh
  If cy + halfh >= #NN_screen_height Then cy = #NN_screen_height - halfh

  BBlit 0, #TX_text_shape, cx, cy, %0

  Free Shape #TX_text_shape
  Free BitMap #TX_scratch_bmp
End Statement

Function .l TX_calc_text_size{id.w, line_width.w}
  !DB_trace{"TX_CORE", "TX_calc_text_size: " + Str$(id) + " " + Str$(line_width)}
  !__use_word_table{}

  DEFTYPE .w word_count
  word_count = !__get_word_count{id}

  DEFTYPE .NN_word *word
  *word = !__get_words{id}

  DEFTYPE .w line_count, remaining, max_width, cur_width, word_width
  line_count = 1
  remaining = line_width
  max_width = 0

  For i = 0 To word_count - 1
    word_width = (*word\end_idx - *word\start_idx + 1)

    If *word\end_idx = -1 OR remaining - word_width < 0
      line_count + 1
      remaining = line_width
      cur_width = 0
    End If

    remaining - (word_width + 1) ; account for the space
    cur_width + word_width

    If max_width < cur_width Then max_width = cur_width
    cur_width + 1 ; account for space

    *word + SizeOf .NN_word
  Next

  DEFTYPE .l size

  size = !__make_size{max_width, line_count}

  Function Return size
End Function

Statement TX_render_wrapped{id.w, line_width.w, x0.w, y0.w}
  !DB_trace{"TX_CORE", "TX_render_wrapped: " + Str$(id) + " " + Str$(line_width) + ", " + Str$(x0) + "," + Str$(y0)}
  !__use_string_table{}
  !__use_word_table{}

  DEFTYPE .w word_count
  word_count = !__get_word_count{id}

  DEFTYPE .NN_word *word
  *word = !__get_words{id}

  DEFTYPE .w remaining, word_width, x, y
  remaining = line_width
  x = x0
  y = y0

  DEFTYPE .b *text
  *text = !__get_string_addr{id}

  For i = 0 To word_count - 1
    word_width = (*word\end_idx - *word\start_idx + 1)

    If *word\end_idx = -1 OR remaining - word_width < 0
      ; Advance to next line
      x = x0
      y + #TX_font_height
      remaining = line_width
    End If
    
    If *word\end_idx <> -1
      ; Print the word
      For j = *word\start_idx To *word\end_idx
        Blit Peek.b(*text + j), x, y, %0
        x + #TX_font_width

      Next j

      remaining - (word_width + 1) ; account for the space
      x + #TX_font_width
    End If

    *word + SizeOf .NN_word
  Next i

End Statement

Statement TX_draw_textid_wrapped{id.w, line_width.w, cx.w, cy.w}
  !DB_trace{"TX_CORE", "TX_drawid_text_wrapped: " + Str$(id) + " " + Str$(line_width) + ", " + Str$(cx) + "," + Str$(cy)}
  SHARED NN_current_bmp, *NN_word_table

  DEFTYPE .l size
  size = TX_calc_text_size{id, line_width}

  DEFTYPE .w width, height
  width = !__get_size_width{size}
  height = !__get_size_height{size}

  BitMap #TX_scratch_bmp, #NN_screen_width, #NN_screen_height, #NN_screen_bpp
  Use BitMap #TX_scratch_bmp

  ; Calculate how big a rectangle this will be, including enough
  ; padding for the text frame
  DEFTYPE .w rect_width, rect_height
  rect_width = width * #TX_font_width + #TX_frame_total_size
  rect_height = height * #TX_font_height + #TX_frame_total_size

  DEFTYPE .w x0, y0
  x0 = #TX_frame_size
  y0 = #TX_frame_size

  ; Draw the frame
  Boxf x0, y0, x0 + rect_width - #TX_frame_total_size, y0 + rect_height - #TX_frame_total_size, 3
  tx_draw_frame{width, height}

  TX_render_wrapped{id, line_width, x0, y0}

  GetaShape #TX_text_shape, 0, 0, rect_width, rect_height
  MidHandle #TX_text_shape
  Use BitMap NN_current_bmp

  DEFTYPE .w halfw, halfh
  halfw = rect_width LSR 1
  halfh = rect_height  LSR 1

  If cx - halfw < 0 Then cx = halfw
  If cx + halfw >= #NN_screen_width Then cx = #NN_screen_width - halfw
  If cy - halfh < 0 Then cy = halfh
  If cy + halfh >= #NN_screen_height Then cy = #NN_screen_height - halfh

  BBlit 0, #TX_text_shape, cx, cy, %0

  Free Shape #TX_text_shape
  Free BitMap #TX_scratch_bmp
End Statement

NEWTYPE .TX_context
  max_width.w
  y_position.w
End NEWTYPE

Statement TX_begin{context.l}
  BitMap #TX_scratch_bmp, #NN_screen_width, #NN_screen_height, #NN_screen_bpp
  Use BitMap #TX_scratch_bmp

    ; Draw the frame
  Boxf 0, 0, #NN_screen_width, #NN_screen_height, 3

  DEFTYPE .TX_context *ctx
  *ctx = context
  *ctx\max_width = 0
  *ctx\y_position = 0
End Statement

Statement TX_end{context.l, x.w, y.w}
  SHARED NN_current_bmp
  DEFTYPE .TX_context *ctx
  *ctx = context

  ; Draw the frame
  tx_draw_frame{*ctx\max_width, *ctx\y_position}

  ; Calculate how big a rectangle this will be, including enough
  ; padding for the text frame
  DEFTYPE .w rect_width, rect_height
  rect_width = *ctx\max_width * #TX_font_width + #TX_frame_total_size
  rect_height = *ctx\y_position * #TX_font_height + #TX_frame_total_size

  GetaShape #TX_text_shape, 0, 0, rect_width, rect_height
  Use BitMap NN_current_bmp

  If x < 0 Then x = 0
  If x + rect_width >= #NN_screen_width Then x = #NN_screen_width - rect_width
  If y < 0 Then y = 0
  If y + rect_height >= #NN_screen_height Then y = #NN_screen_height - rect_height

  BBlit #BF_main_screen, #TX_text_shape, x, y, %0

  Free Shape #TX_text_shape
  Free BitMap #TX_scratch_bmp
End Statement

Function .l TX_put_text{context.l, id.w, line_width.w}
  DEFTYPE .TX_context *ctx
  *ctx = context

  DEFTYPE .w x, y
  x = #TX_frame_size
  y = *ctx\y_position * #TX_font_height + #TX_frame_size

  DEFTYPE .l size
  size = TX_calc_text_size{id, line_width}

  TX_render_wrapped{id, line_width, x, y}

  DEFTYPE .w width, height
  width = !__get_size_width{size}
  height = !__get_size_height{size}

  If *ctx\max_width < width Then *ctx\max_width = width
  *ctx\y_position + height

  !DB_printf{">>>>>>>>>>>>>>>>> Size: (%d, %d), Max width %d", width, height, *ctx\max_width}
  Function Return size
End Function

; context = TX_begin{}
; TX_render{context, "hello"}
; TX_render_wrapped{context, "hello", 32}
; TX_end{context, x, y}

; context = TX_begin{}
; TX_render_wrapped{context, "*Choice 1"}
; TX_render_wrapped{context, "*Choice 2"}
; TX_render_wrapped{context, "*Choice 3"}
; TX_end{context, x, y}

; Hello, this is\na string.

; 0 5 7 10 12 13 -1 15 15 17 22


; NEWTYPE .TX_context
;   max_width.w
;   y_position.w
; End NEWTYPE

; NEWTYPE .NN_rect
;   x.w
;   y.w
;   w.w
;   h.w
; End NEWTYPE

; Function .l TX_begin{}
;   BitMap #TX_scratch_bmp, #NN_screen_width, #NN_screen_height, #NN_screen_bpp
;   Use BitMap #TX_scratch_bmp

;   Function Return #TX_frame_size
; End Function

; Function .l TX_get_rect{id.w, wrap_width.w}
;   !__use_string_table{}

;   DEFTYPE .l addr, strlen
;   addr = !__get_string_addr{id}
;   strlen = Peek.w(addr - 2)


; End Function
; =============================================================================
; SC_Scene
; -----------------------------------------------------------------------------
; Scene related statements and function
; SC Prefix = SCene
;

; Set the background image for a scene
Statement SC_set_bg{id.w}
    NPrint "Setting #", id, " as the scene background"
End Statement
; =============================================================================
; SH_shapes
; -----------------------------------------------------------------------------
; Shape related Statements and Functions
; Prefix SH = SHape

Statement SH_draw {id.w, x.w, y.w}
    NPrint "Drawing shape #", id, " at ", x, ",", y
End Statement
; =============================================================================
; IV_inventory
; -----------------------------------------------------------------------------
; Inventory related statements and functions
; Prefix IV = InVentory
;

Function.b IV_has_item{id.w}
    SHARED IV_user_items()
    ResetList IV_user_items()

    While NextItem(IV_user_items())
        If IV_user_items() = iv Then Function Return True
    WEnd

    Function Return False
End Function

Statement IV_add_item{id.w}
    SHARED IV_user_items()
    If IV_has_item{id}
        NPrint "Player already has item ", id
    Else
        NPrint "Added ", id, " to inventory."
        AddLast IV_user_items()
        IV_user_items() = id
    End If
End Statement

Statement IV_remove_item{id.w}
    SHARED IV_user_items()
    If NOT IV_has_item{id}
        NPrint "Player doesn't have item ", id
        Return
    End If

    ResetList IV_user_items()
    While NextItem(IV_user_items())
        If IV_user_items() = id Then KillItem IV_user_items()
    WEnd
End Statement


; =============================================================================
; MS_music
; -----------------------------------------------------------------------------
; Music and SFX related functionc
; Prefix MS = Music & Sound
;

Statement MS_load_module{id.w, position.w}
  DEFTYPE .b success
  success = LoadTrackerModule(0, !__get_string{id})
  If success = True

    ; ModulePositionJump doesn't seem to exist
    ; If position > 0 Then ModulePositionJump(position)

    success = StartTracker(0)
    If success = False Then !DB_warn{"MS", "Could not play '" + !__get_string{id} + "'"}

  Else
    !DB_warn{"MS", "Could not load '" + !__get_string{id} + "'"}
  End If
End Statement

Statement MS_pause_module{id.w}
  PauseModule
End Statement

Statement MS_unpause_module{id.w}
  PauseModule
End Statement

Statement MS_kill_module{id.w}
  StopTracker
  FreeTrackerModule id
End Statement
; =============================================================================
; NS_opcodes
; -----------------------------------------------------------------------------
; Noir Script Opcodes
;
; Name              Value     Usage         Meaning
#NS_op_noop         = $00   ;| noop        | No operation
; Flag register operations  ;|             |
#NS_op_clear        = $01   ;| clear       | Clears the flag register
#NS_op_set          = $02   ;| set         | Sets the flag register
#NS_op_load         = $03   ;| load id     | Loads flag into register
#NS_op_store        = $04   ;| store id    | Store flag register in to global flag
; Logical operations        ;|             |
#NS_op_and          = $10   ;| and id      | Logical AND with flag and flag register
#NS_op_or           = $11   ;| or id       | Logical OR with flag and flag register
#NS_op_not          = $12   ;| not         | Logical NOT on flag register
; Flow control              ;|             |
#NS_op_jump         = $20   ;| jump N      | Skip the next 'N' words
#NS_op_jift         = $21   ;| jifs N      | Skip the next 'N' words if flag register is true
#NS_op_jiff         = $22   ;| jiff N      | Skip the next 'N' words if flag register is false
#NS_op_end          = $2F   ;| end         | Ends the script prematurely
; Scene operations          ;|             |
#NS_op_setbg        = $30   ;| setbg id    | Set the scene background to bitmap id
; Shape operations          ;|             |
#NS_op_draw         = $40   ;| draw id x y | Draw shape ID at X,Y
; Dialogues
#NS_op_dlg          = $50   ;| dlg id      | Show dialogue id    
#NS_op_choff        = $51   ;| choff id    | Disabled choice #i
#NS_op_chon         = $52   ;| chon id     | Enables choice #id
#NS_op_pageoff      = $53   ;| pageoff id  | Disabled page #i
#NS_op_pageon       = $54   ;| pageon id   | Enables page #id
#NS_op_dlgimg       = $55   ;| dlgimg id   | Changes the speaker's portrait
#NS_op_dlgname      = $5F   ;| dlgname id  | Changes the speaker's name 
#NS_op_dlgend       = $5F   ;| dlgend      | Closes the dialogue 
; Inventory Operations      ;|             |
#NS_op_hasi         = $60   ;| hasi id     | Sets flag register if player has item ID in inventory
#NS_op_addi         = $61   ;| addi id     | Adds item ID to inventory
#NS_op_remi         = $62   ;| remi id     | Remove item ID from inventory
; Music and SFX
#NS_op_mod          = $70   ;| mod id pos  | Loads module named "id" at position pos
#NS_op_modpause     = $71   ;| modpause id | Pauses module id
#NS_op_modplay      = $72   ;| modplay id  | Resume module id
#NS_op_modkill      = $73   ;| modkill id  | Unloads module id
; Game operations           ;|             |
#NS_op_goto         = $80   ;| goto id     | Go to location ID, ends script
#NS_op_map          = $81   ;| map         | Display location selection screen, ends script
#NS_op_text         = $82   ;| text id     | Display string ID
#NS_op_goloc        = $83   ;| goloc loc scene| Loads a location and scene
#NS_op_quit         = $8E   ;| quit        | Quits the game
#NS_op_gameover     = $8F   ;| gameover id | Displays game over with string ID as message, ends script
; =============================================================================
; NS_Script
; -----------------------------------------------------------------------------
; Executes the NOIRscript bytecode
; =============================================================================

Macro __print_bc
  op$ = (`2)
  !DB_printf{"********     %04lx: %02x - %s", (`1), (`1), &op$}
End Macro

Macro __print_bc_v1
  op$ = (`2)
  !DB_printf{"********     %04lx: %02x - %s %d", (`1), (`1), &op$, (`3)}
End Macro

Macro __print_bc_v2
  op$ = (`2)
  !DB_printf{"********     %04lx: %02x - %s %d %d", (`1), (`1), &op$, (`3), (`4)}
End Macro

Macro __execute_opcode
  PC + 2
  !__print_bc{PC, (`1)}
End Macro

Macro __execute_opcode_v1
  PC + 2
  v1 = Peek.w(*NS_script_data + PC)
  !__print_bc{PC - 2, (`1), v1}
  PC + 2
End Macro


Macro __execute_opcode_v2
  PC + 2
  v1 = Peek.w(*NS_script_data + PC)
  PC + 2
  v2 = Peek.w(*NS_script_data + PC)
  !__print_bc_v2{PC - 4, (`1), v1, v2}
  PC + 2
End Macro

; Executes the bytecode pointed to in the script
; Assumes the existence of this global data:
;   NS_data: Word array containing the opcodes to all the scrips
;   NS_flags: Byte array containing all of the game's flags
; And these global statements/functions
;   NN_game_over: Transition to game over screen
;   NN_display_text: Show text on the screen
;   IV_has_item: Check if an item is in the inventory
;   IV_add_item: Adds an item to the inventory
;   IV_remvoe_item: Removes and item from the inventory
;   SH_draw: Draws a shape
;   SC_set_bg: Sets the background in a scene
;   NN_game_set_scene: Goes to a new scene
;   NN_game_map: Display the map with locations
Statement NS_execute_script{script_offset.l}
  !DB_trace{"NS_SCRIPT", "NS_exectute_script: $" + Hex$(script_offset)}
  SHARED *NS_script_data, NS_script_data_size, NS_flags()    ; get a reference to the script data and game flags
  SHARED *NN_string_table
  ; Get the referenced script
  If script_offset > NS_script_data_size
    NPrint "Script offset", script_offset, " out of bounds";
    Statement Return
  End If

  DEFTYPE .l PC
  DEFTYPE .b FR, done

  PC = script_offset * SizeOf .w; Set up program counter
  FR = False                    ; Initialize Flag Register
  done = False

  DEFTYPE .w v1, v2, v3
  Repeat
    Select Peek.w (*NS_script_data + PC)
      Case #NS_op_noop
        PC + 2              ; Eat the opcode
        !__print_bc{PC, "noop"}

      ; Flag register operations
      Case #NS_op_clear
        PC + 2              ; Eat the opcode
        FR = False
        !__print_bc{PC, "clear"}

      Case #NS_op_set
        PC + 2              ; Eat the opcode
        FR = True
        !__print_bc{PC, "set"}

      Case #NS_op_load; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        FR = NS_flags(v1)
        PC + 2              ; Eat the parameter
        !__print_bc_v1{PC, "load", v1}

      Case #NS_op_store; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        NS_flags(v1) = FR
        PC + 2              ; Eat the parameter
        !__print_bc_v1{PC, "store", v1}

      ; Logical operations
      Case #NS_op_and; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        FR AND NS_flags(v1)
        PC + 2              ; Eat the parameter
        !__print_bc_v1{PC, "and", v1}

      Case #NS_op_or; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        FR OR NS_flags(v1)
        PC + 2              ; Eat the parameter
        !__print_bc_v1{PC, "or", v1}

      Case #NS_op_not
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        FR = NOT NS_flags(v1)
        !__print_bc{PC, "not"}

      ; Flow control
      Case #NS_op_jump; offset
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC) - 1
        PC + (v1 ASL 1)
        !__print_bc_v1{PC, "jump", v1}

      Case #NS_op_jift; offset
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC) - 1
        if FR
            PC + (v1 ASL 1)
        Else
            PC + 2              ; Eat the parameter
        End If
        !__print_bc_v1{PC, "jift", v1}

      Case #NS_op_jiff; offset
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC) - 1
        if FR
            PC + 2              ; Eat the parameter
        Else
            PC + (v1 ASL 1)
        End If
        !__print_bc_v1{PC, "jiff", v1}

      Case #NS_op_end
        done = True
        !__print_bc{PC, "end"}

      ; Scene operations
      Case #NS_op_setbg; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "setbg", v1}
        SC_set_bg{v1}
        PC + 2              ; Eat the parameter

      ; Shape operations
      Case #NS_op_draw; id x y
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        v2 = Peek.w (*NS_script_data + PC + 2)
        v3 = Peek.w (*NS_script_data + PC + 4)
        !__print_bc{PC, "draw"}
        SH_draw{v1, v2, v3}
        PC + 6              ; Eat the parameters

      ; Inventory Operations
      Case #NS_op_hasi; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "hasi", v1}
        FR = IV_has_item{v1}
        PC + 2              ; Eat the parameter

      Case #NS_op_addi; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "addi", v1}
        IV_add_item{v1}
        PC + 2              ; Eat the parameter

      Case #NS_op_remi; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "remi", v1}
        IV_remove_item{v1}
        PC + 2              ; Eat the parameter

      ; Game operations
      Case #NS_op_goto; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "goto", v1}
        NN_game_set_scene{v1}
        done = True

      Case #NS_op_map
        PC + 2              ; Eat the opcode
        !__print_bc{PC, "map"}
        NN_game_map{}
        done = True

      Case #NS_op_text; id
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "text", v1}
        TX_draw_text_wrapped{!__get_string{v1}, 32, #NN_half_screen_width , #NN_screen_height}
        PC + 2              ; Eat the parameter

      Case #NS_op_goloc; loc scene
        !__execute_opcode_v2{"goloc"}
        QAMIGA
        NN_load_location{v1, v2}
        BLITZ

      Case #NS_op_quit
        !__execute_opcode{"quit"}
        NN_quit_game{}

      Case #NS_op_gameover
        PC + 2              ; Eat the opcode
        v1 = Peek.w (*NS_script_data + PC)
        !__print_bc_v1{PC, "gameover", v1}
        NN_game_over{v1}
        done = True

      ; Music operations
      Case #NS_op_mod; id pos
        !__execute_opcode_v2{"mod"}
        MS_load_module{v1, v2}

      Case #NS_op_modpause; id
        !__execute_opcode_v1{"modpause"}
        MS_pause_module{v1}

      Case #NS_op_modplay; id
        !__execute_opcode_v1{"modplay"}
        MS_unpause_module{v1}

      Case #NS_op_modkill; id
        !__execute_opcode_v1{"modkill"}
        MS_kill_module{v1}

      ; Dialogue operations
      Case #NS_op_dlg
        !__execute_opcode_v1{"dlg"}
        DG_show_dialog{v1}

      Case #NS_op_choff
        !__execute_opcode_v1{"choff"}
        DG_enable_choice{v1, False}

      Case #NS_op_chon
        !__execute_opcode_v1{"chon"}
        DG_enable_choice{v1, True}

      Case #NS_op_pageoff
        !__execute_opcode_v1{"pageoff"}
        DG_enable_page{v1, False}

      Case #NS_op_pageon
        !__execute_opcode_v1{"pageon"}
        DG_enable_page{v1, True}

      Case #NS_op_dlgimg
        !__execute_opcode_v1{"dlgimg"}
        DG_set_speaker_image{v1}

      Case #NS_op_dlgname
        !__execute_opcode_v1{"dlgname"}
        DG_set_speaker_name{v1}

      Case #NS_op_dlgend
        !__execute_opcode{"dlgend"}
        DG_end{}

      Default
        ; Unknown opcode!
        v1 = Peek.w (*NS_script_data + PC)
        !DB_log_str{"NS_SCRIPT", "Error! Unknown opcode! PC: $" + Hex$(PC) + " Opcode: $" + Hex$(v1)}
        done = True

    End Select
  Until done = True
End Statement

Statement NS_process_queue{}
  SHARED NS_script_queue

  DEFTYPE .w script
  script = NS_script_queue
  NS_script_queue = - 1

  If script <> -1
    NS_execute_script{script}
  End If
End Statement

Statement NS_DEBUG_print_bytecode{}
    SHARED NS_script_data, NS_data_size
    DEFTYPE .w num_entries
    num_entries = NS_data_size / SizeOf .w

    DEFTYPE .s v
    For i = 0 to num_entries - 1
        v = Right$(Hex$(Peek.w (NS_script_data + (i * SizeOf .w))), 4)

        If i MOD 4 = 3
            NPrint v, " "
        Else
            Print v, " "
        End If
    Next
End Statement

; =============================================================================
; DG_dialogue
; -----------------------------------------------------------------------------
; Dialogue related statements and functions
; Prefix DG = DialoGue
;

; Displays and runs the dialog at the given id
; =============================================================================
#DG_x_pos = 112
#DG_width = 32
#DG_x_padding = #DG_x_pos + #TX_frame_size
#DG_y_padding = 8

Function .b dg_is_page_enabled{page_ptr.l}
  SHARED NS_flags()
  DEFTYPE .DG_page *pag
  DEFTYPE .b enabled
  *pag = page_ptr

  enabled = True
  If *pag\check_flag <> -1
    enabled = NS_flags(*pag\check_flag)
  End If

  Function Return enabled AND *pag\enabled
End Function
Function .b dg_is_choice_enabled{choice_ptr.l}
  SHARED NS_flags()
  DEFTYPE .DG_choice *choice
  DEFTYPE .b enabled
  *choice = choice_ptr

  enabled = True
  If *choice\check_flag <> -1
    enabled = NS_flags(*choice\check_flag)
  End If

  Function Return enabled AND *choice\enabled
End Function

Statement DG_show_dialog{id.w}
  !DB_trace{"DG", "DG_show_dialog:" + Str$(id)}
  SHARED DG_dialogue_is_active, NS_script_queue, NS_flags()
  !__use_dialogues{}
  !__use_string_table{}

  DEFTYPE .DG_dialogue *current
  DEFTYPE .DG_page *cur_page
  DEFTYPE .b displayed, lmb, page_id
  DEFTYPE .w pointer_id

; We won't have more than 8 choices, right?
  Dim rects.NN_screen_rect(8) 

  *current = !__get_dialogue{id}
  page_id = *current\first_page_id

  displayed = False
  pointer_id = 0

  DG_dialogue_is_active = True
  While DG_dialogue_is_active
    VWait
    DisplaySprite #CP_coplist, pointer_id, MouseX, MouseY, 0
    lmb = IN_update_mouse{}

    *cur_page = !__get_page{page_id}

    ; If the page is not enabled, advance until we find one that is.
    Repeat
      If dg_is_page_enabled{*cur_page} = False
        page_id = *cur_page\page_id
        displayed = False
      End If
    Until page_id <> -1

    If page_id <> -1
      *cur_page = !__get_page{page_id}
      ; Display the dialog page
      If displayed = False
        UnBuffer 0
        DEFTYPE .TX_context ctx
        TX_begin{&ctx}

        DEFTYPE .l size
        BlitMode InvMode
        size = TX_put_text{&ctx, *cur_page\text_id, #DG_width}
        BlitMode CookieMode

        If *cur_page\first_choice_id <> -1
          ctx\y_position + 1
          DEFTYPE .DG_choice *choice
          DEFTYPE .w cwidth, cheight
          DEFTYPE .b enabled

          For c = 0 To *cur_page\choice_count - 1
            *choice = !__get_choice{*cur_page\first_choice_id + c}

            If dg_is_choice_enabled{*choice}
              rects(c)\x0 = #DG_x_padding
              rects(c)\y0 = (ctx\y_position + 1) * #TX_font_height + #DG_y_padding

              size = TX_put_text{&ctx, *choice\text_id, #DG_width}

              cwidth = !__get_size_width{size}
              cheight = !__get_size_height{size}
              rects(c)\x1 = rects(c)\x0 + (cwidth * #TX_font_width)
              rects(c)\y1 = rects(c)\y0 + (cheight * #TX_font_height)
            Else
              rects(c)\x1 = -1
              rects(c)\y1 = -1
            End If 
          Next
        End If

        TX_end{&ctx, #DG_x_pos, #DG_y_padding}
        displayed = True
      End If

      ; Handle user interaction
      If *cur_page\choice_count > 0
        DEFTYPE .w selected
        DEFTYPE .DG_choice *choice
        selected = IN_check_mouse{&rects(0), *cur_page\choice_count}

        If selected <> -1
          *choice = !__get_choice{(*cur_page\first_choice_id + selected)}
          pointer_id = #NN_pointer_interact - #NN_pointer_start

          If lmb = #IN_mouse_released
            NS_script_queue = *choice\script_offset
            page_id = *choice\page_id
            displayed = False

            If *choice\self_disable = True Then *choice\enabled = False
            If *choice\set_flag <> -1 Then NS_flags(*choice\set_flag) = True
            !DB_printf{"Choice: %d, sf: %d", selected, *choice\set_flag}
          End If
        Else
          pointer_id = #NN_pointer_default - #NN_pointer_start
        End If
      Else
        If lmb = #IN_mouse_released
          page_id = *cur_page\page_id
          displayed = False

          If *cur_page\self_disable = True Then *cur_page\enabled = False
          If *cur_page\set_flag <> -1 Then NS_flags(*cur_page\set_flag) = True
        End If
      End If
    End If

    If page_id = -1 Then DG_dialogue_is_active = False
  Wend

  UnBuffer 0
End Statement

; Enables/Disables a page
; =============================================================================
Statement DG_enable_page{id.w, enabled.b}
  !DB_trace{"DG", "DG_enable_page:" + Str$(id) + ", " + Str$(enabled)}
End Statement

; Enables/Disables a choice
; =============================================================================
Statement DG_enable_choice{id.w, enabled.w}
  !DB_trace{"DG", "DG_enable_choice:" + Str$(id) + ", " + Str$(enabled)}
End Statement

; Changes the speaker's portrait
; =============================================================================
Statement DG_set_speaker_image{image_id.w}
  !DB_trace{"DG", "DG_set_speaker_image:" + Str$(image_id)}
End Statement

; Changes the speaker's name
; =============================================================================
Statement DG_set_speaker_name{name_id.w}
  !DB_trace{"DG", "DG_set_speaker_name:" + Str$(name_id)}
End Statement

; Ends the current dialogue
; =============================================================================
Statement DG_end{}
  !DB_trace{"DG", "DG_end"}
  SHARED DG_dialogue_is_active

  DG_dialogue_is_active = False
End Statement
; =============================================================================
; NN_main
; -----------------------------------------------------------------------------
; Where the magic happens.
; =============================================================================

AMIGA

; PAL has 256 vertical lines, but NTSC only has 200. Center the display
; so that it doesn't look terrible for PAL.
DEFTYPE .w screen_offset
screen_offset = ((DispHeight - 200) LSR 1) + #CP_origin
!DB_log_val{"MAIN", "screen_offset %d", screen_offset}
InitCopList #CP_coplist, screen_offset, #NN_screen_height, #CP_flags, #CP_sprites, #NN_screen_colors, 0

; Set up a buffer for blitting into the main screen
Buffer #BF_main_screen, 64000

Goto SkipSong
; Load the title song
DEFTYPE .b success
success = LoadTrackerModule(0, "data/theme.mod")
If success = True
  success = StartTracker(0)
  If success = False Then !DB_warn{"MAIN", "Could not play title song."}
Else
  !DB_warn{"MAIN", "Could not load title song."}
End If

SkipSong:
; Load the splash screen
BitMap #BMP_main, #NN_screen_width, #NN_screen_height, #NN_screen_bpp
LoadBitMap #BMP_main, "data/mpg.iff", #PAL_main

; Display the splash screen
BLITZ
CreateDisplay #CP_coplist
DisplayBitMap #CP_coplist, #BMP_main
FadeInScreen{#CP_coplist, #PAL_main, #PAL_fx}

; Load the game
QAMIGA
success = NN_initialize{"gutter.neon", "pointers.shape"}
If success <> #NN_NEON_success
  !DB_error{"MAIN", "Could not load game file! Aborting."}
  Goto Finish
End If

TX_initialize{"display.font", "frame.shape"}

VWait 180

; Fade out the splash screen
BLITZ
FadeOutScreen{#CP_coplist, #PAL_main, #PAL_fx}

; Load the title screen
QAMIGA
NN_load_location{0, 0}

; Run the game
DEFTYPE .w pointer_id
DEFTYPE .w overlapped, prev_overlap
DEFTYPE .NN_region *region
DEFTYPE .b left_mouse

pointer_id = 0
overlapped = -1
prev_overlap = -1
NN_should_quit = False

BLITZ
Mouse On

NS_script_queue = -1

Repeat
  VWait

  left_mouse = IN_update_mouse{}

  NN_current_bmp = *NN_current_scene\background_id

  ; Show the background image
  DisplayPalette #CP_coplist, NN_current_bmp
  DisplayBitMap #CP_coplist, NN_current_bmp

  ; Update the mouse pointer
  DisplaySprite #CP_coplist, pointer_id, MouseX, MouseY, 0

  ; Check if any regions that have been hovered over
  overlapped = NN_get_overlapped_region{MouseX, MouseY}

  NS_process_queue{}

  If overlapped <> -1
    *region = !__get_region{overlapped}
    pointer_id = *region\pointer_id

    If left_mouse = #IN_mouse_released AND *region\script_offset <> -1
      UnBuffer #BF_main_screen
      NS_execute_script{*region\script_offset}
    Else
      If overlapped <> prev_overlap AND *region\description_id <> -1
        UnBuffer #BF_main_screen
        TX_draw_text_wrapped{!__get_string{*region\description_id}, 32, #NN_half_screen_width , #NN_screen_height}
        ;TX_draw_textid_wrapped{*region\description_id, 32, #NN_half_screen_width , #NN_screen_height}
      End If
    End If
  Else
    UnBuffer 0
    pointer_id = 0
  End If

  prev_overlap = overlapped

  ; Press ESC to quit
  If RawStatus($45) Then NN_should_quit = True

Until NN_should_quit

Finish:

If success = #NN_NEON_success
  TX_uninitialize{}
  NN_uninitialize{}
End If

StopTracker

; We're done!
End
